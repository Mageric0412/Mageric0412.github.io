---
author: mageric
comments: true
date: 2015-05-29 01:52:50+00:00
layout: post
title: 设计模式个人总结
categories:
- 设计模式
tags:
- 设计模式
---
1. **简单工厂方法**： 对具体方法进行类封装，把封装好的各类方法用类似switch的办法来初始化；这样可以在调用的时候去动态的选择我们所需要使用的方法   
2. **策略模式**： 声明一个策略基类，每种策略都继承自这个基类，同时声明一个管理类，实现两个方法，一个是产生一个策略的具体引用，一个是实现具体的策略类    
3. **装饰模式**：一个抽象类，我们所需要装饰的对象继承自这个抽象类，装饰基类也继承这个抽象类，同时创造一些具体的装饰类，调用时候采用`装饰类1装饰（装饰类2装饰（装饰类装饰（对象）））`这样的顺序，最后只用实现一次最外层装饰类的方法即可完成嵌套装饰    

4. **代理模式**：在代理类中动态实现我们所需代理的对象，并实现对象的具体方法     

5. **工厂方法模式**：定义一个用于创建对象的接口，让子类决定实例化哪个类，类的实例化延迟到子类中（`return new Operation;`）    

6. **原型模式**：原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象，具体原型类的拷贝操作采用浅拷贝`MemberwiseClone（引用同一ICloneable`）    
**浅复制**：仅仅复制内容本身，不复制引用的对象（`MemberwiseClone`），引用都指向同一对象     
**深复制**：引用也复制过去，可以生成不同的克隆个体    
**深复制实现**：克隆类属性以及引用之后，对相关字段再次赋值，返回一个深复制对象    

7. **模板方法模式**：采用模板的方式声明一些抽象类，在具体的类中进行实现（把能用模板代替的共同方法用模板代替）    

8. **外观模式**：为一组接口提供一致的界面，定义一个高层接口，去统一/部分实现其下的接口们    

9. **建造者模式**：将复杂对象的构造与表示分离，每次建造类建造就对展示产生一次注册，使用一个调度者来进行装配，同时可以返回我们的展示方法，提高耦合    
10. **观察者模式**：让多个观察者监听同一主题，每次主题发生变化，则通知所有注册了该主题的观察者。主题类，提供方法来添加注册观察者们，另一方法调用观察者的更新方法通知所有注册观察者。观察者类，提供更新方法相应主题的通知。通过事件委托的方式可以让观察者本不相同的各种方法类型放在一个通知体内，满足观察通知的模式    

11. **抽象工厂方法**：抽象实现各种new对象的方法，采用上行转换基类，调用基类的实现方法来实例化具体的不同的工厂方法。（提供一个创建一系列相关或相互依赖对象的接口而无需指定具体的类）    

12. **状态模式**：类的方法里实现满足某一条件，“递归”实现新的状态类并继续进行这样的判断，这样判断状态的方式就会在类内部进行递归判断    

13. **适配器模式**：将类的接口包装为另一个接口。提供一个中立的翻译类，来翻译一个方法在另一种说明下的不同名称   

14. **备忘录模式**：在不破坏封装性的前提下，捕捉一个对象的内部变量，保存在该对象的外部，以后遇到恢复情况时再加载该保存变量类   

15. **组合模式**：将对象组合成树结构，即对象中可以add多个其他对象，产生一含多的组合形式。满足对同一组对象的统一操作性    

16. **迭代器模式**：提供一种方法顺序访问一个聚合对象中的各个元素而不暴露该对象的内部表示，类似STL中的迭代器操作，实现获取头元素、尾元素、元素个数等操作。将STL遍历运用到聚集对象中    

17. **单例模式**：保证类的单一实例，并提供一个全局访问点。一般采用`static Singleton instance`的写法。如果该`static`变量没有实现，则new一个Instance，否则就返回该static类    
**多线程单例**：采用两次判断，如果instance为空则加一次锁，再一次进行instance判断。最终返回实例（多线程操作问题主要出现在是否对多次new一个新实例上，因此一定要设置锁进行多次实例判断）    

18. **桥接模式**：将抽象部分与实现部分分离，抽象类中的方法是一些抽象的实现方法，每次实现抽象类的具体类，调用对应的抽象方法去实现具体方法。把抽象分离出来到最外层，内部实现的都是具体的方法（手机品牌与手机软件）    

19. **命令模式**：将请求封装为对象，从而对请求排队进行处理（类似WIN32的消息队列），命令基类中存在执行方法、以及接收者，具体命令类指定接收者，唤醒类中实现了命令的执行方法    

20. **职责链模式**：使多个对象都有机会处理请求，形成链式传递请求直到完成。类似状态模式，“递归”的设置消息传递的继承者，只用传递消息给链的开端对象就能处理这个消息，完成处理则“断链”     

21. **中介者模式**：用中立对象来封装对象间的交互（**迪米特法则**），中立对象保存交互的两个对象，如果对象1发送消息则给对象2接收，反之亦然。两个对象内实现一个对中立对象发送消息的方法，对象本身来实现之前这个中立对象发送信息的方法，就能通过中立对象进行发送    

22. **享元模式**：共享使用。类似采用Hashtable的办法保存每次新生成的对象，如果下一次遇到已经保存过的对象内容需要生成，则无需再生成新的对象，直接调用已经生成对象的相应展示方法即可    

23. **解释器模式**：定义多个语言的文法以及解释器，来解释同一文件中的同一句子中的不同文法。定义一个抽象解释器，有抽象解释方法，从而继承实现不同的解释器以及不同的解释方法。从而可以通过在List中添加实现多个解释器的方式，来批量循环调用解释器列表，进行批量解释。（乐谱音符，多态）    

24. **访问者模式**：作用于某对象结构中的各元素的操作，在不改变各元素类的前提下定义这些新操作。抽象访问者类，之后具体的访问者要实现他们的抽象访问方法。抽象元素类，之后的具体类要实现获得具体访问者的元素。通过访问元素的多次具体封装，让我们的访问者可以根据不同的访问元素去具体实现各自访问者内对应该元素的具体反应。（将访问者进行入队，模式根据访问者的类别，针对不同的状态生成访问者的反应）    


### 设计原则
**单一职责（SRP）**：一个类只有一个引起变化的原因    
**开放封闭**：类模块函数可以扩展，但不可修改     
**依赖倒转**：高层不依赖底层、抽象不依赖细节，两者都依赖于抽象     
**里氏代换（LSP）**：子类需要能够替换父类    
**迪米特法则（LoD）**：其中一个类需要调用另一个的方法，使用间接通信而非直接     
**合成/聚合复用原则（CARP）**：尽量使用合成聚合，少使用类继承
