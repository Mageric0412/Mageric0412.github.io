---
author: mageric
comments: true
date: 2015-08-03 05:50:18+00:00
layout: post
title: Java内存管理原理及区域简介
categories:
- Java
tags:
- 内存管理，jvm
---
&#160; &#160; &#160; &#160;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：
![Java内存区域详解](http://7xvk1t.com1.z0.glb.clouddn.com/image/java/jvm.gif)
下面就每一个区域进行阐述。

### 运行时数据区域

#### 程序计数器
&#160; &#160; &#160; &#160;程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。     
&#160; &#160; &#160; &#160;多线程中，为了让线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间互不影响、独立存储，因此这块内存是线程私有的。     
&#160; &#160; &#160; &#160;当线程正在执行的是一个Java方法，这个计数器记录的是在正在执行的虚拟机字节码指令的地址；当执行的是Native方法，这个计数器值为空。    
&#160; &#160; &#160; &#160;此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域 。

#### Java虚拟机栈
&#160; &#160; &#160; &#160;Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链表、方法出口信息等。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。    
&#160; &#160; &#160; &#160;局部变量表中存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。     
&#160; &#160; &#160; &#160;如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

#### 本地方法栈
&#160; &#160; &#160; &#160;本地方法栈与虚拟机的作用相似，不同之处在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。有的虚拟机直接把本地方法栈和虚拟机栈合二为一。    
&#160; &#160; &#160; &#160;会抛出stackOverflowError和OutOfMemoryError异常。    
**Java堆**     
&#160; &#160; &#160; &#160;Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例。    
&#160; &#160; &#160; &#160;Java堆是垃圾收集器管理的主要区域。由于现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代和老年代。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(TLAB)。     
&#160; &#160; &#160; &#160;Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。如果堆中没有内存完成实例分配，并且堆也无法完成扩展时，将会抛出OutOfMemoryError异常。    
**方法区**    
&#160; &#160; &#160; &#160;方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，当方法区无法满足内存分配需要时，将抛出OutOfMemoryError异常。    
运行时常量池：是方法区的一部分，它用于存放编译期生成的各种字面量和符号引用。    
**直接内存**     
&#160; &#160; &#160; &#160;直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。     
&#160; &#160; &#160; &#160;直接内存的分配不会受到Java堆大小的限制，但是会受到本机内存大小的限制，所有也可能会抛OutOfMemoryError异常。

### 对象的创建、布局和访问过程
**对象的创建**      
&#160; &#160; &#160; &#160;创建一个对象通常是需要new关键字，当虚拟机遇到一条new指令时，首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果那么执行相应的类加载过程。    
&#160; &#160; &#160; &#160;类加载检查通过后，虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。分配的方式有两种：    
一种叫**指针碰撞**：假设Java堆中内存是绝对规整的，用过的和空闲的内存各在一边，中间放着一个指针作为分界点的指示器，分配内存就是把那个指针向空闲空间的那边挪动一段与对象大小相等的距离。     
另一种叫**空闲列表**：如果Java堆中的内存不是规整的，虚拟机就需要维护一个列表，记录哪个内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。   
&#160; &#160; &#160; &#160;采用哪种分配方式是由Java堆是否规整决定的，而Java堆是否规整是由所采用的垃圾收集器是否带有压缩整理功能决定的。另外一个需要考虑的问题就是对象创建时的线程安全问题，有两种解决方案：一是对分配内存空间的动作进行同步处理；另一种是吧内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存(TLAB)，哪个线程要分配内存就在哪个线程的TLAB上分配，只有TLAB用完并分配 新的TLAB时才需要同步锁定。   
&#160; &#160; &#160; &#160;内存分配完成后，虚拟机需要将分配到的内存空间初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就可以直接使用。接下来虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息等，这些信息存放在对象的对象头中。    
&#160; &#160; &#160; &#160;上面的工作都完成以后，从虚拟机的角度来看一个新的对象已经产生了。但是从Java程序的角度，还需要执行init方法，把对象按照[程序员](http://www.codeceo.com/)的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

#### 对象的内存布局
&#160; &#160; &#160; &#160;在HotSpot虚拟机中，对象在内存中存储的布局可分为三个部分： 对象头、实例数据和对齐填充。     
&#160; &#160; &#160; &#160;对象头包括两个部分：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、线程所持有的锁等。官方称之为“Mark Word”。第二个部分为是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。    
&#160; &#160; &#160; &#160;实例数据是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。对齐填充并不是必然存在的，仅仅起着占位符的作用。、Hotpot VM要求对象起始地址必须是8字节的整数倍，对象头部分正好是8字节的倍数，所以当实例数据部分没有对齐时，需要通过对齐填充来对齐。

#### 对象的访问定位
&#160; &#160; &#160; &#160;Java程序通过栈上的reference数据来操作堆上的具体对象。主要的访问方式有使用句柄和直接指针两种：    
&#160; &#160; &#160; &#160;**句柄**：Java堆将会划出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。如图所示：
![Java内存区域详解](http://7xvk1t.com1.z0.glb.clouddn.com/image/java/jb.gif)
&#160; &#160; &#160; &#160;**直接指针**：Java堆对象的布局要考虑如何放置访问类型数据的相关信息，引用中存储的就是对象地址 。如图所示：
![Java内存区域详解](http://7xvk1t.com1.z0.glb.clouddn.com/image/java/jb2.gif)
&#160; &#160; &#160; &#160;两个方式各有优点，使用句柄最大的好处是引用中存储的是稳定的句柄地址，对象被移动时只会改变句柄中实例的地址，引用不需要修改、使用直接指针访问的好处是速度更快，它节省了一次指针定位的时间开销。
