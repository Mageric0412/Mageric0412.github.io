<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>经典数据结构与算法</title>
  <meta name="description" content="链表       链表是一种非常基本的数据结构，被广泛的用在各种语言的集合框架中。首先链表是一张表，只不过链表中的元素在内存中不一定相邻，并且每个元素都可带有指向另一个元素的指针。         链表有，单项链表，双向链表，循环链表等。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="经典数据结构与算法">
  <meta name="twitter:description" content="链表       链表是一种非常基本的数据结构，被广泛的用在各种语言的集合框架中。首先链表是一张表，只不过链表中的元素在内存中不一定相邻，并且每个元素都可带有指向另一个元素的指针。         链表有，单项链表，双向链表，循环链表等。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="经典数据结构与算法">
  <meta property="og:description" content="链表       链表是一种非常基本的数据结构，被广泛的用在各种语言的集合框架中。首先链表是一张表，只不过链表中的元素在内存中不一定相邻，并且每个元素都可带有指向另一个元素的指针。         链表有，单项链表，双向链表，循环链表等。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="/2015/08/list/">
  <link rel="alternate" type="application/rss+xml" title="Mageric" href="/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Mageric 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Mageric logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Mageric" class="blog-button">Mageric</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">42 世界尽头</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Mageric的个人小站.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">Blog</a></li>
                
                  <li class="navigation__item"><a href="http://mageric-one.com" target="_blank" title="My old site">OldSite</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/magericyoung" title="@magericyoung 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/Mageric0412" title="@Mageric0412 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  

  
  <!-- instagram -->
  <li class="navigation__item">
   <a href="https://www.instagram.com/mageric0412" title="@mageric0412 的Instagram" target="_blank">
     <i class='social fa fa-instagram'></i>
     <span class="label">instagram</span>
   </a>
  </li>
  

<!--
  
  <!-- website -->
  <!--
  <li class="navigation__item">
    <a href="https://mageric-one.com" rel="author" title="mageric的小站" target="_blank">
        <i class='social fa fa-rss'> </i>
      <span class="label">website</span>
    </a>
  </li>
  
-->




  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:mageric0412@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-red"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-08-03 00:39:38 +0800" itemprop="datePublished" class="post-meta__date date">2015-08-03</time> &#8226; <span class="post-meta__tags tags">算法</span>
    </div>
    <h1 class="post-title">经典数据结构与算法</h1>
  </header>

  <section class="post">
    <h3 id="section">链表</h3>
<p>       链表是一种非常基本的数据结构，被广泛的用在各种语言的集合框架中。首先链表是一张表，只不过链表中的元素在内存中不一定相邻，并且每个元素都可带有指向另一个元素的指针。  <br />
       链表有，单项链表，双向链表，循环链表等。</p>

<h4 id="section-1">单项链表的数据结构</h4>
<p>       如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">     <span class="k">typedef</span> <span class="k">struct</span> <span class="n">NODE</span><span class="p">{</span>
         <span class="k">struct</span> <span class="n">NODE</span> <span class="o">*</span> <span class="n">link</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
     <span class="p">}</span> <span class="n">Node</span><span class="p">;</span></code></pre></figure>

<h4 id="section-2">对链表的操作</h4>
<p>       主要有增删查：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Node</span> <span class="o">*</span> <span class="n">create</span><span class="p">(){</span>
        <span class="n">Node</span> <span class="o">*</span> <span class="n">head</span><span class="p">,</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
        <span class="c1">//  这里创建不带头节点的链表
</span>        <span class="n">head</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">do</span>
        <span class="p">{</span>
            <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">LEN</span><span class="p">);</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%ld"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>

            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="c1">//  第一次插入
</span>            <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
                <span class="n">head</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
            <span class="n">tail</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">delete</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span><span class="n">linkp</span><span class="p">,</span><span class="kt">int</span> <span class="n">del_value</span><span class="p">){</span>
        <span class="k">register</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">current</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span> <span class="n">m_del</span><span class="p">;</span>
        <span class="c1">//寻找正确的删除位置，方法是按顺序访问链表，直到到达等于的节点
</span>        <span class="k">while</span><span class="p">((</span><span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">linkp</span><span class="p">)</span><span class="o">!=</span><span class="nb">NULL</span>  <span class="o">&amp;&amp;</span>  <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">!=</span> <span class="n">del_value</span><span class="p">)</span>
        <span class="p">{</span>    
            <span class="n">linkp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">==</span><span class="n">current</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">//把该节点删除，返回TRUE
</span>            <span class="n">m_del</span><span class="o">=</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
            <span class="o">*</span><span class="n">linkp</span><span class="o">=</span><span class="n">m_del</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//需要形参为链表头指针的地址和要插入的值
</span>    <span class="kt">int</span> <span class="n">insert</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span><span class="n">linkp</span><span class="p">,</span><span class="kt">int</span> <span class="n">new_value</span><span class="p">){</span>
        <span class="k">register</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">current</span><span class="p">;</span>
        <span class="n">Node</span> <span class="o">*</span> <span class="n">m_new</span><span class="p">;</span>

        <span class="c1">//寻找真确的插入位置，方法是按顺序访问链表，直到到达其值大于或等于新插入值的节点
</span>        <span class="k">while</span><span class="p">((</span><span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">linkp</span><span class="p">)</span><span class="o">!=</span><span class="nb">NULL</span>  <span class="o">&amp;&amp;</span>  <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">new_value</span><span class="p">)</span>
        <span class="p">{</span>    
            <span class="n">linkp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//为新节点分配内存，并把新值存到新节点中，如果分配失败，返回FALSE
</span>        <span class="n">m_new</span> <span class="o">=</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">LEN</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">==</span><span class="n">m_new</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="n">m_new</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
        <span class="c1">//把新节点放入链表，返回TRUE
</span>
        <span class="n">m_new</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="o">*</span><span class="n">linkp</span><span class="o">=</span><span class="n">m_new</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       仅仅只需要将尾指针指向头节点，就可以构成单项循环链表，即tail-&gt;link=head;，有的时候，可能需要将链表逆置，当然，如果需要逆置，最好一开始就做双向链表。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Node</span> <span class="o">*</span> <span class="n">reverse</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">head</span><span class="p">){</span>
        <span class="n">Node</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span><span class="o">*</span><span class="n">q</span><span class="p">;</span>
        <span class="n">q</span><span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">{</span>    
            <span class="c1">//  接到新链表里面去
</span>            <span class="n">q</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="n">head</span>  <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
            <span class="c1">//  继续遍历原来的链表
</span>            <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span>  <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">return</span>  <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       删除链表中所有值为x的节点，以及清除链表中重复的节点</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//    功能：    删除链表中所有值为x的节点
</span>    <span class="c1">//    形参：    1、若不带头结点，便是链表头指针的地址，即&amp;head
</span>    <span class="c1">//            2、若带头结点，便是链表头节点的next域的地址，即&amp;head-&gt;next
</span>    <span class="c1">//    形参：    为链表头指针的地址和要删除的值
</span>    <span class="kt">void</span> <span class="n">del_link</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span> <span class="n">plink</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="k">register</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">while</span><span class="p">((</span><span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">plink</span><span class="p">)</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 处理连续出现x的情况
</span>            <span class="k">while</span><span class="p">(</span><span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">x</span><span class="p">){</span>
                <span class="c1">//  保留指向下一个节点的指针
</span>                <span class="n">Node</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
                <span class="o">*</span> <span class="n">plink</span> <span class="o">=</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="c1">//  删除当前节点
</span>                <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">//向下遍历链表
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//    功能：    删除链表中重复多余的节点
</span>    <span class="c1">//    形参：    1、若不带头结点，便是链表头指针的地址，即&amp;head
</span>    <span class="c1">//            2、若带头结点，便是链表头节点的next域的地址，即&amp;head-&gt;next
</span>    <span class="kt">void</span> <span class="n">del_linkAll</span><span class="p">(</span><span class="n">Node</span> <span class="o">**</span> <span class="n">plink</span><span class="p">){</span>
        <span class="k">register</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">while</span><span class="p">((</span><span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">plink</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="c1">//注意，这里取指向下一个元素的指针的地址，这样删除是会保留这一个节点
</span>            <span class="n">del_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
            <span class="n">plink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>       对于双向链表，也就是在节点中再添加一个节点，让它与另一个指针指向的方向相反。当然，当节点有了两个节点之后，就可以构成更复杂的比如树图等复杂结构了，双向链表可像如下定义：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#ifndef __LINKLISTEX_H__
</span>    <span class="cp">#define __LINKLISTEX_H__
</span>    <span class="cp">#include &lt;string&gt;
</span>    <span class="n">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
    <span class="c1">//================双向链表的定义===============
</span>    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">class</span> <span class="n">DulLinkList</span>
    <span class="p">{</span>
    <span class="n">private</span><span class="o">:</span>
        <span class="k">typedef</span> <span class="k">struct</span> <span class="n">DulNode</span><span class="p">{</span>
            <span class="k">struct</span> <span class="n">DulNode</span> <span class="o">*</span> <span class="n">prior</span><span class="p">;</span>
            <span class="n">T</span>    <span class="n">data</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">DulNode</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span><span class="n">DulNode</span><span class="p">;</span>
        <span class="n">DulNode</span> <span class="o">*</span> <span class="n">frist</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">Init</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">Del</span><span class="p">(</span><span class="n">DulNode</span> <span class="o">*</span> <span class="n">delNode</span><span class="p">);</span>
    <span class="n">public</span><span class="o">:</span>
        <span class="n">DulLinkList</span><span class="p">();</span>
        <span class="o">~</span><span class="n">DulLinkList</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">AddElem</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span>  <span class="n">data</span><span class="p">);</span>
        <span class="kt">void</span> <span class="n">DelElem</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">ToString</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="n">protected</span><span class="o">:</span>
    <span class="p">};</span>
    <span class="cp">#endif//__LINKLISTEX_H__</span></code></pre></figure>

<p>       对双向链表的操作也无外乎增删改：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include "LinkListEx.h"
</span>    <span class="cp">#include &lt;iostream&gt;
</span>    <span class="n">using</span> <span class="n">namespace</span>  <span class="n">std</span><span class="p">;</span>

    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">DulLinkList</span><span class="p">(){</span>
        <span class="n">Init</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Init</span><span class="p">(){</span>
        <span class="c1">// 初始化第一个结点
</span>        <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span> <span class="o">=</span> <span class="n">new</span> <span class="n">DulNode</span><span class="p">;</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">AddElem</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">){</span>
        <span class="c1">// 直接头部插入节点
</span>        <span class="n">DulNode</span> <span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">new</span> <span class="n">DulNode</span><span class="p">;</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="p">;</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">DelElem</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">){</span>
        <span class="n">DulNode</span> <span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current</span>  <span class="o">!=</span> <span class="nb">NULL</span>  <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Del</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Del</span><span class="p">(</span><span class="n">DulNode</span> <span class="o">*</span> <span class="n">delNode</span><span class="p">){</span>
        <span class="c1">// 调整当前节点两端的节点的指针
</span>        <span class="n">delNode</span><span class="o">-&gt;</span><span class="n">prior</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">delNode</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">delNode</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prior</span> <span class="o">=</span> <span class="n">delNode</span><span class="o">-&gt;</span><span class="n">prior</span><span class="p">;</span>
        <span class="n">delete</span> <span class="n">delNode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">DulLinkList</span><span class="p">(){</span>
        <span class="n">DulNode</span> <span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">DulNode</span> <span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">delete</span> <span class="n">old</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">string</span> <span class="n">DulLinkList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ToString</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
        <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">DulNode</span> <span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">frist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       链表是个很基础的东西，后面一些复杂的算法或数据结构的本质也是一个链表。链表和顺序表（也就是数组）都可以再进一步抽象成更复杂的数据结构。   <br />
       比如队列和栈，不过是在链表或顺序表的基础上限制单端操作而已。再比如，由链表和顺序表还可以构成二叉树堆，它们还可以组合使用构成邻接表，十字链表，邻接多重表等结构用来描述图，等等。</p>

<h3 id="section-3">字符串相关算法</h3>
<p>       做里快两年web开发了，可以说字符串是用多最多的数据类型了，所以针对字符串的算法也非常的多。先从简单的慢慢来。  <br />
       首先最基本的是对字符串的求长，连接，比较，复制等：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// 统计字符串长度
</span>    <span class="kt">int</span> <span class="n">str_len</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">){</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">str</span> <span class="o">?</span> <span class="n">str_len</span><span class="p">(</span><span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 字符串复制
</span>    <span class="kt">void</span> <span class="n">str_cpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">str2</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">str1</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">str2</span><span class="o">++</span><span class="p">);</span> <span class="c1">//当str2指向'\0'时，赋值给*str1 表达式的值为0 即为假。退出循环
</span>            <span class="c1">//if(*str1 == '\0')    // 考虑到 串2的长度大于串1的长度，防止指针越界
</span>                <span class="c1">//break;
</span>    <span class="p">}</span>
    <span class="c1">// 字符串比较
</span>    <span class="kt">int</span> <span class="n">str_cmp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">str2</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">// i指向字符不同时数组下标
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 字符串连接
</span>    <span class="kt">void</span> <span class="n">str_cat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">str2</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">str1</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
            <span class="n">str1</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">str1</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">str2</span><span class="o">++</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>       字符串比较复杂一点的就是模式匹配和子序列（编辑距离）的问题。  <br />
       首先是较为简单的BF算法，这种算法原理非常简单，比如连个串a（主串）和b（模式串），首先将a1和b1进行比较，如果相同，则将b2与a2进行比较，如果还相同，继续拿a3与b3比，直到b串匹配完，怎匹配完成，如果出现不同的，怎回到最初的状态，将b1与a2进行比较，将b2与a3比较，等等，如此反复直到失败或成功。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="p">}</span><span class="n">String</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">Index_BF</span><span class="p">(</span><span class="n">String</span> <span class="n">mainStr</span><span class="p">,</span><span class="n">String</span> <span class="n">modeStr</span><span class="p">,</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
        <span class="kt">int</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span>    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mainStr</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">modeStr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mainStr</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">modeStr</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="c1">// 出现不同的，回退到模式第一个字符的状态，将模式右移进行匹配
</span>                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">modeStr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">modeStr</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>       较为复杂的算法是<a href="http://www.codeceo.com/article/kmp-algorithms.html">kmp算法</a>，KMP算法的关键是避免BF算法中的回朔。并且当匹配失败后向右滑动到一个能自左最大对齐的位置继续匹配。  <br />
       若在ai,bj的位置匹配失败，所以已经匹配的串便是：  <br />
<code class="highlighter-rouge">B1 B2 … Bj-1 == Ai-j+1 Ai-j+2 … Ai-1</code>;
假设滑动完后要让Bk与Ai对齐，则应该有：  <br />
<code class="highlighter-rouge">B1 B2 B3 … Bk-1 == Ai-k+1 A-k+2 … Ai-1</code>;  <br />
       因为是向右滑动，想一想i的位置不变，B向右滑动，很显然，k要小于j。所以进一步可以得到k到j之间B的子串（Bj前面的k-1个字符）与Ai前的k-1个字符是相同的，即：  <br />
<code class="highlighter-rouge">Bj-k+1 Bj-k+2 … Bj-1 == Ai-k+1 Ai-k+2 … Ai-1</code>;   <br />
       所以有：  <br />
<code class="highlighter-rouge">B1 B2 B3 … Bk-1  == Bj-k+1 Bj-k+2 … Bj-1</code>;  <br />
       可以看出来，这个有个特点，字符串B1 B2 .. Bj-1关于Bk有种对称的感觉，不过这个不是镜像对称，不过我还是喜欢这么记<code class="highlighter-rouge">对称</code>,这也是求next值的依据，这个next就是k，就是偏移值。   <br />
<code class="highlighter-rouge">next(j) = 0 (j==1) || max{k|1&lt;=k&lt;j &amp;&amp; B1 B2 B3 … Bk-1  == Bj-k+1 Bj-k+2 … Bj-1} || 1</code>;  <br />
       下面是完整的KMP算法：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">void</span> <span class="n">GetNext</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">mode</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span> <span class="n">next</span><span class="p">){</span>
        <span class="c1">//求模式mode的next值并存入数组next中
</span>        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">next</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
            <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">j</span> <span class="o">||</span> <span class="n">mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mode</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
                <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">Index_KMP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">mode</span><span class="p">,</span><span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">GetNext</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="n">next</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;=</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="n">j</span> <span class="o">||</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mode</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="c1">// 滑动模式串，注意next[j]是小于j的，这才是向右滑动
</span>                <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span>  <span class="n">i</span> <span class="o">-</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
        <span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\016</span><span class="s">abcabcabaabcac"</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">mode</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">"</span><span class="se">\010</span><span class="s">abaabcac"</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"模式串在主串中的位置:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">Index_KMP</span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span></code></pre></figure>

<p>       下面的问题是最长公共子序列，算法的思想是动态规划，核心是转义方程：
<img src="http://7xvk1t.com1.z0.glb.clouddn.com/image/algorithms/kmp.png" alt="" />
       也就是当两个字符相等时取左上元素+1，不相等时取左和上中大的那个：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;string.h&gt;
</span>    <span class="cp">#define MAXN 128
</span>    <span class="cp">#define MAXM MAXN
</span>    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXM</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"ABCBDAB"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"BDCABA"</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">LCS</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">){</span>
            <span class="k">for</span><span class="p">(</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>          <span class="c1">//如果想等，则从对角线加1得来
</span>                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>    <span class="c1">//否则判段它上面、右边的值，将大的数给他
</span>                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span><span class="p">{</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="p">}</span>

            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">cSubQ</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]){</span>
            <span class="n">cSubQ</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">str</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">cSubQ</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">cSubQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str2</span><span class="p">);</span>
        <span class="n">LCS</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">str2</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
        <span class="n">cSubQ</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
        <span class="n">str</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       很显然，这个算法的时间复杂度和空间复杂度为<strong>o(n*m)</strong>。</p>

<h3 id="section-4">二叉树</h3>
<p>       树这里主要以二叉树为例，二叉树算是一种特殊的树，一种特殊的图。二叉树具备如下特征：  <br />
1. 第i层最多有2^(i-1)次方个节点  <br />
2. 深度为k的树最多有2^i-1个节点，也就是满二叉树等比求和   <br />
3. n0=n2+1，即叶子节点的数量恰好是度为2的节点数加1，主要原因是节点数总比度数多1，因为根节点没有入度，所以有 n0 + n1 + n2 -1 = n1 + 2<em>n2。  <br />
4. 对于满二叉树，如果以有序表存储，根节点放在0的位置上，左右孩子放在1,2上，相当于从上到下，从左到右，从0开始对节点进行编号，则对于节点i，它的左孩子应该位于2</em>i+1上，右孩子位于2*i+2上。   <br />
用数组和链表都可以存储二叉树，但我见过的算法大都用数组存储二叉树，想必链表虽然易于理解，但相比写起算法来未必好写。</p>

<h4 id="section-5">对二叉树的操作</h4>
<p>       有增删查遍历等操作，代码如下。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">bitnode</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">m_iDate</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">bitnode</span> <span class="o">*</span> <span class="n">m_lChild</span><span class="cm">/*左孩子指针*/</span><span class="p">,</span><span class="o">*</span> <span class="n">m_rChild</span><span class="cm">/*右孩子指针*/</span><span class="p">;</span>        
    <span class="p">}</span> <span class="n">CBiTNode</span><span class="p">;</span>
    <span class="c1">//建立一个带头结点的空的二叉树
</span>    <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">Initiate</span><span class="p">(){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">bt</span><span class="p">;</span>
        <span class="n">bt</span> <span class="o">=</span> <span class="p">(</span><span class="n">CBiTNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">CBiTNode</span><span class="p">);</span>
        <span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">bt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*
    //建立一个不带头结点的空的二叉树
    CBiTNode * Initiate(){
        CBiTNode * bt;
        bt = NULL;
        return bt;
    }
    */</span>
    <span class="c1">//生成一棵以x为根节点数据域信息，以lbt和rbt为左右子树的二叉树
</span>    <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">lbt</span><span class="p">,</span><span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">rbt</span><span class="p">){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">CBiTNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">CBiTNode</span><span class="p">))</span> <span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="n">lbt</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="n">rbt</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//在二叉树bt中的parent所指节点和其左子树之间插入数据元素为x的节点
</span>    <span class="n">bool</span> <span class="n">InsertL</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">parent</span><span class="p">){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"L插入有误"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">((</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">CBiTNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">CBiTNode</span><span class="p">))</span> <span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">;</span>
            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//在二叉树bt中的parent所指节点和其右子树之间插入数据元素为x的节点
</span>    <span class="n">bool</span> <span class="n">InsertR</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">parent</span><span class="p">){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"R插入有误"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">((</span><span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="n">CBiTNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">CBiTNode</span><span class="p">))</span> <span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">;</span>
            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//在二叉树bt中删除parent的左子树
</span>    <span class="n">bool</span> <span class="n">DeleteL</span><span class="p">(</span><span class="n">CBiTNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"L删除出错"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">;</span>
        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//当*p为分支节点时，这样删除只是删除了子树的根节点。子树的子孙并没有被删除
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//在二叉树bt中删除parent的右子树
</span>    <span class="n">bool</span> <span class="n">DeleteR</span><span class="p">(</span><span class="n">CBiTNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">){</span>
        <span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">parent</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"R删除出错"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">;</span>
        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//当*p为分支节点时，这样删除只是删除了子树的根节点。子树的子孙并没有被删除
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//二叉树的遍历
</span>    <span class="c1">//先序遍历二叉树
</span>    <span class="n">bool</span> <span class="n">PreOrder</span><span class="p">(</span><span class="n">CBiTNode</span> <span class="o">*</span> <span class="n">bt</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bt</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"bt-&gt;m_iDate == %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_iDate</span><span class="p">);</span>
            <span class="n">PreOrder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">);</span>
            <span class="n">PreOrder</span><span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>       对二叉树可以有先序遍历，中序遍历，后序遍历得到的序列中每个元素互第一个和最后一个节点外都会有一个前驱和后驱节点。如果把前驱节点和后驱节点的信息保存在节点中就构成了线索二叉树，显然只要免礼一遍就能得到线索二叉树。  <br />
       二叉树比较经典的有哈夫曼编码问题，二叉堆等问题，二叉堆放到堆排序一起讲。   <br />
       哈夫曼问题就是要让频率高的节点编码最短，也就是要节点在哈夫曼树中的深度最小：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">//    Huffman.h
</span>    <span class="cp">#ifndef __HUFFMAN_H__
</span>    <span class="cp">#define __HUFFMAN_H__
</span>    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span><span class="n">lchild</span><span class="p">,</span><span class="n">rchild</span><span class="p">;</span>
    <span class="p">}</span><span class="n">HTNode</span><span class="p">,</span><span class="o">*</span> <span class="n">HuffmanTree</span><span class="p">;</span>            <span class="c1">// 动态分配数组储存哈夫曼树
</span>    <span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="n">HuffmanCode</span><span class="p">;</span>    <span class="c1">// 动态分配数组储存哈夫曼编码表
</span>    <span class="cp">#endif//__HUFFMAN_H__
</span>
    <span class="c1">//    HuffmanTest.cpp
</span>    <span class="cp">#include "Huffman.h"
</span>    <span class="cp">#include &lt;string.h&gt;
</span>    <span class="cp">#include &lt;malloc.h&gt;
</span>    <span class="c1">// 函数功能：在哈夫曼编码表HT[1...range]中选择 parent 为0且weight最小的两个结点，将序号分别存到s1和s2里
</span>    <span class="kt">void</span> <span class="n">Select</span><span class="p">(</span><span class="k">const</span> <span class="n">HuffmanTree</span> <span class="o">&amp;</span><span class="n">HT</span><span class="p">,</span><span class="kt">int</span> <span class="n">range</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span> <span class="n">pFlags</span><span class="p">;</span>
        <span class="n">pFlags</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">range</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="kt">int</span> <span class="n">iFlags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">range</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parent</span><span class="p">){</span>
                <span class="n">pFlags</span><span class="p">[</span><span class="o">++</span><span class="n">iFlags</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">Min</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pMin</span><span class="o">=</span><span class="n">pFlags</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">iFlags</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">pFlags</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">Min</span><span class="p">){</span>
                <span class="n">pMin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">Min</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">pFlags</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">weight</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">s1</span><span class="o">=</span><span class="n">pFlags</span><span class="p">[</span><span class="n">pMin</span><span class="p">];</span>
        <span class="n">Min</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">iFlags</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">pFlags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">s1</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">HT</span><span class="p">[</span><span class="n">pFlags</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">Min</span><span class="p">){</span>
                    <span class="n">pMin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                    <span class="n">Min</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">pFlags</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">weight</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">s2</span><span class="o">=</span><span class="n">pFlags</span><span class="p">[</span><span class="n">pMin</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">HuffmanCoding</span><span class="p">(</span><span class="n">HuffmanTree</span> <span class="o">&amp;</span><span class="n">HT</span><span class="p">,</span><span class="n">HuffmanCode</span> <span class="o">&amp;</span><span class="n">HC</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
        <span class="c1">// w存放n个字符的权值（均&gt;0），构造哈夫曼树HT，并求出n个字符的哈夫曼编码HC
</span>        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">HT</span> <span class="o">=</span> <span class="p">(</span><span class="n">HuffmanTree</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HTNode</span><span class="p">));</span>        <span class="c1">// 0 单元不使用
</span>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">HuffmanTree</span> <span class="n">p</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 初始化哈夫曼编码表
</span>        <span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">HT</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">p</span><span class="o">++</span><span class="p">,</span><span class="n">w</span><span class="o">++</span><span class="p">){</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span> <span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 建立哈夫曼树
</span>        <span class="kt">int</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">Select</span><span class="p">(</span><span class="n">HT</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">);</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">s1</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">HT</span><span class="p">[</span><span class="n">s2</span><span class="p">].</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lchild</span> <span class="o">=</span> <span class="n">s1</span><span class="p">,</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rchild</span> <span class="o">=</span> <span class="n">s2</span><span class="p">;</span>
            <span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span> <span class="o">=</span> <span class="n">HT</span><span class="p">[</span><span class="n">s1</span><span class="p">].</span><span class="n">weight</span><span class="o">+</span><span class="n">HT</span><span class="p">[</span><span class="n">s2</span><span class="p">].</span><span class="n">weight</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 从叶子节点到根逆向求每个字符的哈夫曼编码
</span>        <span class="n">HC</span> <span class="o">=</span> <span class="p">(</span><span class="n">HuffmanCode</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>        <span class="c1">// 分配n个字符编码的头指针向量
</span>        <span class="kt">char</span> <span class="o">*</span> <span class="n">cd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>            <span class="c1">// 分配求编码的工作空间
</span>        <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>                                            <span class="c1">// 编码起始位置
</span>        <span class="n">cd</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>                                        <span class="c1">// 编码结束符
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>                                    <span class="c1">// 逐个字符求哈夫曼编码
</span>            <span class="n">start</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>                                    <span class="c1">// 将编码起始位置和末位重合
</span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parent</span><span class="p">;</span><span class="n">f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span><span class="o">=</span><span class="n">f</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="n">HT</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">parent</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">HT</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">lchild</span><span class="p">)</span>
                    <span class="n">cd</span><span class="p">[</span><span class="o">--</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'0'</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">cd</span><span class="p">[</span><span class="o">--</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">HC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>    <span class="c1">// 为第i个字符编码分配空间
</span>            <span class="n">strcpy</span><span class="p">(</span><span class="n">HC</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">cd</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>                        <span class="c1">// 从 cd 复制字符串到 HC
</span>        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">cd</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>哈夫曼树的测试数据：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include "Huffman.h"
</span>    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;stdlib.h&gt;
</span>    <span class="kt">void</span> <span class="n">HuffmanCoding</span><span class="p">(</span><span class="n">HuffmanTree</span> <span class="o">&amp;</span><span class="n">HT</span><span class="p">,</span><span class="n">HuffmanCode</span> <span class="o">&amp;</span><span class="n">HC</span><span class="p">,</span><span class="kt">int</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"color F0"</span><span class="p">);</span>
        <span class="n">HuffmanTree</span> <span class="n">HT</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">HuffmanCode</span> <span class="n">HC</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">chArr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="sc">'A'</span><span class="p">,</span><span class="sc">'B'</span><span class="p">,</span><span class="sc">'C'</span><span class="p">,</span><span class="sc">'D'</span><span class="p">,</span><span class="sc">'E'</span><span class="p">,</span><span class="sc">'F'</span><span class="p">,</span><span class="sc">'G'</span><span class="p">,</span><span class="sc">'H'</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
        <span class="n">HuffmanCoding</span><span class="p">(</span><span class="n">HT</span><span class="p">,</span><span class="n">HC</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span>    <span class="s">"HT    weight   parent  lchild  rchild</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">15</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%02d</span><span class="se">\t</span><span class="s">%2u</span><span class="se">\t</span><span class="s">%2u</span><span class="se">\t</span><span class="s">%2u</span><span class="se">\t</span><span class="s">%2u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="p">,</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">parent</span><span class="p">,</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lchild</span><span class="p">,</span><span class="n">HT</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rchild</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">字符    权值    编码</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\t</span><span class="s">%2d</span><span class="se">\t</span><span class="s">%-8s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">chArr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">HC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p><img src="http://7xvk1t.com1.z0.glb.clouddn.com/image/algorithms/hufman.jpg" alt="" /></p>

<h3 id="section-6">图相关算法</h3>
<p>       图是一种比较复杂的数据结构，图的定义就不在此复述了。</p>

<h4 id="section-7">图的一些表示方法（存储结构）</h4>

<h5 id="section-8">邻接矩阵</h5>
<ul>
  <li>对于一个又n个节点的图，邻接矩阵以一个n*n的二维数组a来描述图，对于不同的图，比如，有向图和无向图，带权图和无权图，a[i,j]表示的含义有所不同，但都是描述边的。</li>
</ul>

<h5 id="section-9">邻接表</h5>
<ul>
  <li>邻接表组合使用数组和链表描述图，其中数组的每一个元素代表一个节点i，i由两部分组成，一部分代表节点的数据，另一部分为一个指向一链表，这个链表里存放着能从节点i出发能走到的所有节点。对于有向图和无向图会有不同的表示。邻接表一般要比领接矩阵更省空间，但它带来了求入度不便等问题。</li>
</ul>

<h5 id="section-10">十字链表</h5>
<ul>
  <li>结合使用邻接表与逆邻接表，这种方式只能描述有向图。首先它也有一个数组，每个数据元素代表一个节点i，i由三部分组成，i在邻接表的基础上增加了一个指针，这个指针指向第一个以i为弧尾的及节点。这就很好的解决了求入度的问题。</li>
</ul>

<h5 id="section-11">邻接多重表</h5>
<ul>
  <li>邻接多重表主要，它主要用来表描述无向图，在邻接表或十字链表中，数组元素的指针域指向的链表元素其实代表了边，如果用邻接表来存无向图，会使得一条边对应的两个节点分别位于两条链中，当我需要删除一条边时，总是需要找到另一个表示这条边的边节点，再删除。所以有了邻接多重表，邻接多重表就是只用一个边界点表示边，但是将它链接到两链表中。（一个节点，同时存在于两个链表中）  <br />
       下面是上面四种描述的代码表示：</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#ifndef __GRAPH_DEFINE_H__
</span>    <span class="cp">#define __GRAPH_DEFINE_H__
</span>    <span class="cp">#define INT_MAX            9999
</span>    <span class="cp">#define INFINITY        INT_MAX            // 最大值
</span>    <span class="cp">#define MAX_VERTEX_NUM    20                // 最大顶点个数
</span>    <span class="cp">#define VEX_FORM        "%c"            // 顶点输入格式
</span>    <span class="cp">#define INFO_FORM        "%d"            // 边信息输入格式
</span>    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">InfoType</span><span class="p">;</span>            <span class="c1">// 弧相关信息类型
</span>    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">VextexType</span><span class="p">;</span>        <span class="c1">// 顶点数据类型
</span>    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">VRType</span><span class="p">;</span>                <span class="c1">// 顶点关系类型,对无权图，用0或者1表示是否相邻。对带权图，则是权值类型。
</span>    <span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">DG</span><span class="p">,</span><span class="n">DN</span><span class="p">,</span><span class="n">UDG</span><span class="p">,</span><span class="n">UDN</span><span class="p">}</span> <span class="n">GraphKind</span><span class="p">;</span><span class="c1">// 图类型 {有向图，有向网，无向图，无向网}
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    邻接矩阵存储结构: 可存储任意类型图
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
        <span class="n">VRType</span>        <span class="n">Adj</span><span class="p">;</span>
        <span class="n">InfoType</span>    <span class="n">Info</span><span class="p">;</span>                    <span class="c1">// 该弧相关信息
</span>    <span class="p">}</span><span class="n">ArcCell</span><span class="p">,</span><span class="n">AdjMatrix</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
        <span class="kt">char</span> <span class="n">cVexs</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>            <span class="c1">// 顶点向量
</span>        <span class="n">AdjMatrix</span> <span class="n">arcs</span><span class="p">;</span>                        <span class="c1">// 邻接矩阵
</span>        <span class="kt">int</span> <span class="n">iVexNum</span><span class="p">,</span><span class="n">iArcNum</span><span class="p">;</span>                <span class="c1">// 图中当前顶点数和弧数
</span>        <span class="n">GraphKind</span> <span class="n">kind</span><span class="p">;</span>                        <span class="c1">// 图的种类标志
</span>    <span class="p">}</span><span class="n">MGraph</span><span class="p">;</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    邻接表存储结构:    可存储任意类型的图
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">ArcNode</span><span class="p">{</span>
        <span class="kt">int</span>                <span class="n">iAdjvex</span><span class="p">;</span>        <span class="c1">// 该弧所指向的顶点位置
</span>        <span class="k">struct</span> <span class="n">ArcNode</span>    <span class="o">*</span><span class="n">nextarc</span><span class="p">;</span>        <span class="c1">// 指向下一条弧的指针
</span>        <span class="n">InfoType</span>        <span class="n">Info</span><span class="p">;</span>            <span class="c1">// 该弧相关信息
</span>    <span class="p">}</span><span class="n">ArcNode</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">VNode</span><span class="p">{</span>
        <span class="n">VextexType</span>    <span class="n">cData</span><span class="p">;</span>                <span class="c1">// 顶点信息
</span>        <span class="n">ArcNode</span>        <span class="o">*</span><span class="n">firstarc</span><span class="p">;</span>            <span class="c1">// 指向第一条依附该顶点的弧的指针
</span>    <span class="p">}</span><span class="n">VNode</span><span class="p">,</span><span class="n">AdjList</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">AdjList</span>        <span class="n">vertices</span><span class="p">;</span>
        <span class="kt">int</span>            <span class="n">iVexnum</span><span class="p">,</span><span class="n">iArcnum</span><span class="p">;</span>    <span class="c1">// 图的当前顶点个数和弧数
</span>        <span class="n">GraphKind</span>    <span class="n">Kind</span><span class="p">;</span>                <span class="c1">// 图的种类标志
</span>    <span class="p">}</span><span class="n">ALGraph</span><span class="p">;</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    十字链表存储结构: 只存储有向图
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">ArcBox</span><span class="p">{</span>
        <span class="kt">int</span>                <span class="n">iTailVex</span><span class="p">,</span><span class="n">iHeadVex</span><span class="p">;</span>        <span class="c1">// 该弧的尾和头顶点的位置
</span>        <span class="k">struct</span> <span class="n">ArcBox</span>    <span class="o">*</span><span class="n">hLink</span><span class="p">,</span><span class="o">*</span><span class="n">tLink</span><span class="p">;</span>            <span class="c1">// 分别为弧头相同和弧尾相同的链域
</span>        <span class="n">InfoType</span>        <span class="n">Info</span><span class="p">;</span>                    <span class="c1">// 该弧相关信息
</span>    <span class="p">}</span><span class="n">ArcBox</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">VexNode</span><span class="p">{</span>
        <span class="n">VextexType</span>        <span class="n">data</span><span class="p">;</span>
        <span class="n">ArcBox</span>            <span class="o">*</span><span class="n">firstIn</span><span class="p">,</span><span class="o">*</span><span class="n">firstOut</span><span class="p">;</span>        <span class="c1">// 分别指向了该顶点的第一条入弧和出弧
</span>    <span class="p">}</span><span class="n">VexNode</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">OLGraph</span><span class="p">{</span>
        <span class="n">VexNode</span>        <span class="n">xlist</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>        <span class="c1">// 表头向量
</span>        <span class="kt">int</span>            <span class="n">iVexNum</span><span class="p">,</span><span class="n">iArcNum</span><span class="p">;</span>            <span class="c1">// 有向图当前顶点数和弧数
</span>    <span class="p">}</span><span class="n">OLGraph</span><span class="p">;</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    邻接多重表:    存储无向图
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">unvisited</span><span class="p">,</span><span class="n">visited</span><span class="p">}</span><span class="n">VisitIf</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">EBox</span><span class="p">{</span>
        <span class="n">VisitIf</span>            <span class="n">mark</span><span class="p">;</span>            <span class="c1">// 访问标记
</span>        <span class="kt">int</span>                <span class="n">iIVex</span><span class="p">,</span><span class="n">iJVex</span><span class="p">;</span>    <span class="c1">// 边依附的两个顶点的位置
</span>        <span class="k">struct</span> <span class="n">EBox</span>        <span class="o">*</span><span class="n">iLink</span><span class="p">,</span><span class="o">*</span><span class="n">jLink</span><span class="p">;</span>    <span class="c1">// 分别指向依附这两个顶点的下一条边
</span>        <span class="n">InfoType</span>        <span class="n">Info</span><span class="p">;</span>            <span class="c1">// 该边信息指针
</span>    <span class="p">}</span><span class="n">EBox</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">VexBox</span><span class="p">{</span>
        <span class="n">VextexType</span>        <span class="n">data</span><span class="p">;</span>
        <span class="n">EBox</span>            <span class="o">*</span><span class="n">firstEdge</span><span class="p">;</span>        <span class="c1">// 指向第一条依附该顶点的边
</span>    <span class="p">}</span><span class="n">VexBox</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">VexBox</span>            <span class="n">adjmulist</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
        <span class="kt">int</span>                <span class="n">iVexNum</span><span class="p">,</span><span class="n">iEdgeNum</span><span class="p">;</span>    <span class="c1">// 无向图当前顶点数和边数
</span>    <span class="p">}</span>
    <span class="cp">#endif//__GRAPH_DEFINE_H__</span></code></pre></figure>

<h4 id="section-12">图相关操作</h4>
<p>       对图的操作有创建，增删查等等，其中查就是遍历，遍历分为<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>。  <br />
       <strong>深度优先搜索</strong>类似于树的钟旭遍历，即遇到未范围的节点，马上访问，修改标记数组，然后沿着这个节点继续访问，直到访问完，然后在回朔，转向未访问的分支。直到节点被访问完，如果是连通图，只要访问进行一次深度搜索，如果是非连通的，就要搜索多次。  <br />
       <strong>广度优先搜索</strong>就像金字塔从上向下的一层一层的搜索，广度优先搜索除了需要用标记数组记录状态以外，还需要用队列来将发现而未访问的节点记录下来。用队列是为了保证遍历顺序。  <br />
       下面是一些图相关的操作算法</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include "GraphDefine.h"
</span>    <span class="cp">#include "Define.h"
</span>    <span class="cp">#include &lt;malloc.h&gt;
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    邻接矩阵图的相关操作
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="n">Status</span> <span class="n">CreateDG</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造有向图
</span>    <span class="n">Status</span> <span class="n">CreateDN</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造有向网
</span>    <span class="n">Status</span> <span class="n">CreateUDG</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">);</span>    <span class="c1">// 构造无向图
</span>    <span class="n">Status</span> <span class="n">CreateUDN</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">);</span>    <span class="c1">// 构造无向网
</span>    <span class="kt">int</span> <span class="n">LocateVex</span><span class="p">(</span><span class="k">const</span> <span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="k">const</span> <span class="n">VextexType</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>    <span class="c1">// 获得顶点v在图中的位置
</span>    <span class="n">Status</span> <span class="n">CreateGraph</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="n">VextexType</span> <span class="n">v</span><span class="p">){</span>
        <span class="c1">// 采用数组（邻接矩阵）表示法，构造图G
</span>        <span class="kt">int</span> <span class="n">iType</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%*c"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">iType</span><span class="p">);</span>
        <span class="n">G</span><span class="p">.</span><span class="n">kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">GraphKind</span><span class="p">)</span><span class="n">iType</span><span class="p">;</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">DG</span><span class="p">:</span> <span class="k">return</span> <span class="n">CreateDG</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造有向图
</span>        <span class="k">case</span> <span class="n">DN</span><span class="p">:</span> <span class="k">return</span> <span class="n">CreateDN</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造有向网
</span>        <span class="k">case</span> <span class="n">UDG</span><span class="p">:</span><span class="k">return</span> <span class="n">CreateUDG</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造无向图
</span>        <span class="k">case</span> <span class="n">UDN</span><span class="p">:</span><span class="k">return</span> <span class="n">CreateUDN</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>        <span class="c1">// 构造无向网
</span>        <span class="nl">default:</span>
            <span class="k">return</span> <span class="n">ERROR</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Status</span> <span class="n">CreateUDN</span><span class="p">(</span><span class="n">MGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">){</span>
        <span class="c1">//  采用数组（邻接矩阵）表示法，构造网G
</span>        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">IncInfo</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">iArcNum</span><span class="p">,</span><span class="o">&amp;</span><span class="n">IncInfo</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>            <span class="c1">// 构造顶点向量
</span>            <span class="n">scanf</span><span class="p">(</span><span class="s">"%c%*c"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">G</span><span class="p">.</span><span class="n">cVexs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>        <span class="c1">// 初始化邻接矩阵
</span>                <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Adj</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="p">;</span>
                <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Info</span> <span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>        
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">VextexType</span> <span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iArcNum</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>            <span class="c1">// 构造邻接矩阵
</span>            <span class="n">scanf</span><span class="p">(</span><span class="s">"%c %c %d%*c"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v1</span><span class="p">),</span><span class="n">j</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v2</span><span class="p">);</span>    <span class="c1">// 确定v1,v2在G中的位置
</span>            <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Adj</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>            <span class="c1">// 弧&lt;v1,v2&gt;的权值
</span>            <span class="k">if</span><span class="p">(</span><span class="n">IncInfo</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="n">INFO_FORM</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Info</span><span class="p">);</span>
            <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">arcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>    <span class="c1">// 置&lt;v1,v2&gt;对称弧&lt;v2,v1&gt;
</span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    十字链表图的相关操作
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="kt">int</span> <span class="n">LocateVex</span><span class="p">(</span><span class="k">const</span> <span class="n">OLGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">,</span><span class="k">const</span> <span class="n">VextexType</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>    <span class="c1">// 获得顶点v在图中的位置
</span>    <span class="n">Status</span> <span class="n">CreateDG</span><span class="p">(</span><span class="n">OLGraph</span> <span class="o">&amp;</span><span class="n">G</span><span class="p">){</span>
        <span class="c1">// 采用十字链表存储表示，构造有向图 G(G.kind = DG)
</span>        <span class="n">InfoType</span> <span class="n">IncInfo</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">iArcNum</span><span class="p">,</span><span class="o">&amp;</span><span class="n">IncInfo</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>            <span class="c1">// 构造表头向量
</span>            <span class="n">scanf</span><span class="p">(</span><span class="n">VEX_FORM</span> <span class="s">"%*c"</span><span class="p">,</span><span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>            <span class="c1">// 输入顶点值
</span>            <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstIn</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstOut</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">// 初始化指针
</span>        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
        <span class="n">VextexType</span>    <span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">;</span>
        <span class="n">ArcBox</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iArcNum</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>            <span class="c1">// 输入各弧并构造十字链表
</span>            <span class="n">scanf</span><span class="p">(</span><span class="n">VEX_FORM</span> <span class="n">VEX_FORM</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>            <span class="c1">// 输入一条弧的始点和终点
</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v1</span><span class="p">),</span><span class="n">j</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v2</span><span class="p">);</span>    <span class="c1">// 确定V1和 V2在G中的位置
</span>            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcBox</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcBox</span><span class="p">));</span>        <span class="c1">// 假设有足够的空间
</span>            <span class="c1">// 对弧节点赋值
</span>            <span class="n">p</span><span class="o">-&gt;</span><span class="n">iTailVex</span> <span class="o">=</span> <span class="n">v1</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iHeadVex</span> <span class="o">=</span> <span class="n">v2</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">hLink</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstIn</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tLink</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstOut</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">Info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">firstIn</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">firstOut</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// 完成在入弧与出弧的链头的插入
</span>            <span class="k">if</span><span class="p">(</span><span class="n">IncInfo</span><span class="p">)</span> <span class="n">scanf</span><span class="p">(</span><span class="n">INFO_FORM</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Info</span><span class="p">);</span>            <span class="c1">//若含有相关信息，则输入
</span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    深度优先搜索
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="n">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="n">Status</span><span class="p">(</span><span class="o">*</span><span class="n">VisitFunc</span><span class="p">)(</span><span class="kt">int</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">FirstAdjVex</span><span class="p">(</span><span class="n">MGraph</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">NextAdjVex</span><span class="p">(</span><span class="n">MGraph</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span>  <span class="n">DFSTeaverse</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span><span class="n">Status</span> <span class="p">(</span><span class="o">*</span><span class="n">Visit</span><span class="p">)(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)){</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">VisitFunc</span> <span class="o">=</span> <span class="n">Visit</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">DFS</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">VisitFunc</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">FirstAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span> <span class="n">w</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">NextAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    广度优先搜索
</span>    <span class="c1">//////////////////////////////////////////////////////////////////////////
</span>    <span class="c1">//    队列相关函数
</span>    <span class="kt">void</span> <span class="n">InitQueue</span><span class="p">(</span><span class="kt">int</span> <span class="p">[]);</span>
    <span class="kt">void</span> <span class="n">EnQueue</span><span class="p">(</span><span class="kt">int</span> <span class="p">[]);</span>
    <span class="n">bool</span> <span class="n">QueueEmpty</span><span class="p">(</span><span class="kt">int</span> <span class="p">[]);</span>
    <span class="kt">void</span> <span class="n">DFSTeaverse</span><span class="p">(</span><span class="n">MGraph</span> <span class="n">G</span><span class="p">,</span><span class="n">Status</span> <span class="p">(</span><span class="o">*</span><span class="n">Visit</span><span class="p">)(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)){</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">Q</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
        <span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">iVexNum</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">Visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
                <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span>
                    <span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
                    <span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
                    <span class="k">for</span><span class="p">(</span> <span class="n">w</span> <span class="o">=</span> <span class="n">FirstAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">u</span><span class="p">);</span> <span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">NextAdjVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">u</span><span class="p">))</span>
                        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                            <span class="n">Visit</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>       与图相关的还有很多算法，比如求最小生成树的<strong>prim算法</strong>和<strong>kruskal算法</strong>  <br />
       <strong>prim算法</strong>初始化一个s集合，始终挑选与s集合相连最小的边连接的节点加到集合中，然后更新剩余节点到s的距离，直到所有的点添加进了s集合，prim算法代码如下：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;string.h&gt;
</span>    <span class="cp">#define MAXN 1024
</span>    <span class="cp">#define INF 0xeFFFFFFF
</span>    <span class="kt">int</span> <span class="n">e</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="n">bool</span> <span class="n">inSet</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prim</span><span class="p">(){</span>
        <span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
        <span class="n">inSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">inSet</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">inSet</span><span class="p">));</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="c1">//现在所有点到S的距离就是到0的距离
</span>            <span class="n">low</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">minv</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">//找出与集合s相连的最小的边
</span>            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">inSet</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minv</span><span class="p">){</span>
                    <span class="n">minv</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">p</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">minv</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//非连通图
</span>            <span class="c1">//将顶点j加到S里面
</span>            <span class="n">inSet</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="c1">//将最短路径加到结果里
</span>            <span class="n">res</span> <span class="o">+=</span> <span class="n">low</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
            <span class="c1">//更新low数组
</span>            <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">inSet</span> <span class="o">&amp;&amp;</span> <span class="n">low</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">k</span><span class="p">]){</span>
                    <span class="n">low</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
            <span class="n">e</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">prim</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">res</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       <strong>Kruskal算法</strong>不断选取最小的边i，只要biani加进来不构成回路，则加入到边的集合e中来，直到加入的边能连接所有的顶点，则结束算法：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;string.h&gt;
</span>    <span class="cp">#include &lt;stdlib.h&gt;
</span>    <span class="cp">#define MAXN 1024
</span>    <span class="cp">#define INF 0xeFFFFFFF
</span>    <span class="c1">//定义边的结构
</span>    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">Ele</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>    <span class="c1">//边的端点
</span>        <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>      <span class="c1">//边的权重
</span>        <span class="n">bool</span> <span class="n">inSet</span><span class="p">;</span>
    <span class="p">}</span><span class="n">Ele</span><span class="p">;</span>
    <span class="n">Ele</span> <span class="o">*</span> <span class="n">eles</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">//对于n个顶点，最多有n*(n-1)条边
</span>    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span><span class="c1">//m条边
</span>    <span class="kt">int</span> <span class="n">pa</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
    <span class="kt">void</span> <span class="n">make_set</span><span class="p">(){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">find_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">]){</span>
            <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">bool</span> <span class="n">unin_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">yp</span> <span class="o">=</span> <span class="n">find_set</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">xp</span> <span class="o">==</span> <span class="n">yp</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//构成回路，不能合并
</span>        <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">xp</span><span class="p">]</span><span class="o">&gt;</span><span class="n">r</span><span class="p">[</span><span class="n">yp</span><span class="p">]){</span>
            <span class="n">pa</span><span class="p">[</span><span class="n">yp</span><span class="p">]</span> <span class="o">=</span> <span class="n">xp</span><span class="p">;</span><span class="c1">//zhi小的放在zhi大的下面
</span>        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">pa</span><span class="p">[</span><span class="n">xp</span><span class="p">]</span> <span class="o">=</span> <span class="n">yp</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">xp</span><span class="p">]</span> <span class="o">==</span> <span class="n">r</span><span class="p">[</span><span class="n">yp</span><span class="p">]){</span>
                <span class="n">r</span><span class="p">[</span><span class="n">yp</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">sort</span><span class="p">(){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">eles</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">eles</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">w</span><span class="p">){</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="n">i</span><span class="p">){</span>
                <span class="n">Ele</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eles</span><span class="p">[</span><span class="n">p</span><span class="p">];</span><span class="n">eles</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/*
    int cmp(void * a,void * b){
        return (Ele*)a-&gt;w - (Ele*)b-&gt;w;
    }
    */</span>
    <span class="kt">int</span> <span class="n">klske</span><span class="p">(){</span>
        <span class="c1">//将边由小到大排序
</span>        <span class="c1">//qsort(eles,sizeof(eles),sizeof(eles[0]),cmp)
</span>        <span class="n">sort</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">unin_set</span><span class="p">(</span><span class="n">find_set</span><span class="p">(</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">),</span><span class="n">find_set</span><span class="p">(</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">))){</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="k">else</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">,</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
        <span class="c1">//eles = (Ele*)malloc(n*sizeof(Ele));
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="p">;</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">);</span>
            <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ele</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Ele</span><span class="p">));</span>
            <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
            <span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">inSet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">klske</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">res</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">free</span><span class="p">(</span><span class="n">eles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<p>       上面主要涉及的是一些数据结构，以及这些数据结构最基本的算法，下面进入算法部分。</p>

<h3 id="section-13">查找算法</h3>

<h4 id="section-14">树表查找</h4>

<h5 id="section-15">线索二叉树</h5>
<p>       线索二叉树要求任何几节点的左子树比该节点的值小，右子树的值比该节点大。二叉排序树，主要涉及的是插入和搜索：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;malloc.h&gt;
</span>    <span class="k">typedef</span> <span class="k">struct</span> <span class="n">bsTree</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">m_iDate</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">bsTree</span> <span class="o">*</span> <span class="n">m_lChild</span><span class="cm">/*左孩子指针*/</span><span class="p">,</span><span class="o">*</span> <span class="n">m_rChild</span><span class="cm">/*右孩子指针*/</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">*</span> <span class="n">BsTree</span><span class="p">,</span><span class="n">BsNode</span> <span class="p">;</span>
    <span class="n">BsTree</span>  <span class="n">insert</span><span class="p">(</span><span class="n">BsTree</span>  <span class="n">bs</span><span class="p">,</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">BsNode</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bs</span><span class="p">;</span>
        <span class="n">BsNode</span> <span class="o">*</span> <span class="n">note</span>  <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">BsNode</span> <span class="o">*</span> <span class="n">ct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_iDate</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="c1">// 记录上一个节点
</span>                <span class="n">note</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_iDate</span><span class="p">)</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">;</span>
                <span class="k">else</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="n">BsNode</span> <span class="o">*</span> <span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BsNode</span><span class="p">));</span>
        <span class="n">ct</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">ct</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ct</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="p">){</span>
            <span class="n">bs</span> <span class="o">=</span> <span class="n">ct</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">note</span><span class="o">-&gt;</span><span class="n">m_iDate</span><span class="p">){</span>
            <span class="n">note</span><span class="o">-&gt;</span><span class="n">m_lChild</span> <span class="o">=</span> <span class="n">ct</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="n">note</span><span class="o">-&gt;</span><span class="n">m_rChild</span> <span class="o">=</span> <span class="n">ct</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">bs</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">BsNode</span> <span class="o">*</span> <span class="n">search</span><span class="p">(</span><span class="n">BsTree</span> <span class="n">bs</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">bs</span> <span class="o">||</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">m_iDate</span> <span class="o">==</span> <span class="n">x</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">bs</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">m_iDate</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">m_lChild</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">m_rChild</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<h4 id="section-16">有序表查找</h4>
<p><a href="http://www.codeceo.com/article/binary-search.html">二分查找</a>：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="n">binarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">){</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">){</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 返回可插入位置
</span>    <span class="p">}</span></code></pre></figure>

<h3 id="section-17">排序算法</h3>

<h4 id="section-18">选择排序</h4>
<p>以升序为例，每次扫描数组，找到最小的元素直接挪到第一个来，再在剩余的数组中重复这样的操作：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">void</span> <span class="n">selectSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span><span class="n">i</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">i</span><span class="p">){</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>选择排序的平均时间复杂度也是O(n^2)。</p>

<h4 id="section-19">直接插入排序</h4>
<p>直接插入排序不断在前面已经有序的序列中插入元素，并将元素向后挪。再重取一个元素重复这个操作：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#define MAXSIZE   20
</span>    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">KeyType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">KeyType</span> <span class="n">key</span><span class="p">;</span>
    <span class="p">}</span><span class="n">RedType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
        <span class="n">RedType</span> <span class="n">r</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="p">}</span><span class="n">SqList</span><span class="p">;</span>
    <span class="c1">//---------------------直接插入排序---------------------
</span>    <span class="kt">void</span> <span class="n">InsertSort</span><span class="p">(</span><span class="n">SqList</span> <span class="o">&amp;</span> <span class="n">L</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>插入排序的平均时间复杂度也是O(n^2)。</p>

<h4 id="section-20">堆排序</h4>
<p>       堆排序也是一种插入排序，不过是向二叉堆中插入元素，而且以堆排序中的方式存储二叉堆，则二叉堆必定是一棵完全二叉树，堆排序设计的主要操作就是插入和删除之后的堆调整，使得堆保持为大底堆或者小底堆的状态。也就是根节点始终保持为最小或最大，每次删除元素，就将根节点元素与最后元素交换，然后将堆的大小减1，然后进行堆调整，如此反复执行这样的删除操作。很显然，大底堆最后会得到递增序列，小底堆会得到递减序列。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cm">/**
    *  堆调整
    *   在节点数为n的堆中从i节点开始进行堆调整
    */</span>
    <span class="kt">void</span> <span class="n">heapAjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="p">,</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
        <span class="c1">// 从i节点开始调整堆成为小底堆
</span>        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">min</span><span class="p">;</span>
        <span class="c1">// 左孩子，对于节点i，它的左孩子就是2i+1，右孩子就是2i+2;
</span>        <span class="k">for</span><span class="p">(;(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="n">min</span> <span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]){</span>
                <span class="c1">//  将小元素放置到堆顶
</span>                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">heapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
        <span class="c1">// 建堆
</span>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="n">heapAjust</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 取堆顶，调整堆
</span>        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="c1">//  每次取堆顶最小的元素与最后的元素交换，最后会得到递减序列
</span>            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="c1">//  删除一个元素后需要从根元素起重新调整堆
</span>            <span class="n">heapAjust</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>排序的平均时间复杂度为O(NLogN)。</p>

<h4 id="section-21">快速排序</h4>
<p>       说到快排，就想起了大一上学期肖老师（教我C语言的老师）与我讨论的问题，当时懵懂无知，后才才知道那就是快排。快排的思想也很简单，以升序为例，在序列中选一标杆，一般讲第一个元素作为标杆，然后将序列中比标杆小的元素放到标杆左边，将比标杆大的放到标杆右边。然后分别在左右两边重复这样的操作。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">void</span> <span class="n">ksort</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
        <span class="c1">//  长度小于2有序
</span>        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">){</span>
            <span class="c1">// 向右去找到第一个比标杆大的数
</span>            <span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
            <span class="c1">// 向左去找第一个比标杆小的数
</span>            <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span> <span class="c1">// 前面找到的两个数相对于标杆逆序 ，需交换过来 。l==r 不需要交换，
</span>        <span class="p">}</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span><span class="c1">// 将标杆挪到正确的位置.
</span>        <span class="c1">// 对标杆左右两边重复算法,注意，这个l已经跑到r后面去了
</span>        <span class="n">ksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
        <span class="n">ksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>快速排序的平均时间复杂度为O(NLogN)。</p>

<h4 id="section-22">合并排序</h4>
<p>       合并排序采用分治法的思想对数组进行分治，对半分开，分别对左右两边进行排序，然后将排序后的结果进行合并。按照这样的思想，递归做是最方便的。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="kt">void</span> <span class="n">mergeSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">){</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="c1">// 分别最左右两天排序
</span>            <span class="n">mergeSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
            <span class="n">mergeSort</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
            <span class="c1">// 合并排序后的数组
</span>            <span class="n">tmp</span>  <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">c</span><span class="p">[</span><span class="n">tmp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
                <span class="k">else</span> <span class="n">c</span><span class="p">[</span><span class="n">tmp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="c1">//  把剩余的接上
</span>            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span><span class="p">(;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">tmp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">mid</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">tmp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="c1">// 将c数组覆盖到a里
</span>            <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2015/08/javamemory/" title="link to Java内存管理原理及区域简介">Java内存管理原理及区域简介</a></h2>
       <p class="excerpt">       Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干不同的数据区域，这些区域都有各自的用途以及创建和销毁的时间。Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示：下面就每一个区域进行阐述。运行时数据区域程序计数器       程序计数器，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作就是通过改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数...&hellip;</p>
       <div class="post-list__meta"><time datetime="2015-08-03 13:50:18 +0800" class="post-list__meta--date date">2015-08-03</time> &#8226; <span class="post-list__meta--tags tags">内存管理，jvm</span><a class="btn-border-small" href=/2015/08/javamemory/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2015/07/jvm/" title="link to JVM相关知识整理（转）">JVM相关知识整理（转）</a></h2>
       <p class="excerpt">       JVM是虚拟机，也是一种规范，他遵循着冯·诺依曼体系结构的设计原理。冯·诺依曼体系结构中，指出计算机处理的数据和指令都是二进制数，采用存储程序方式不加区分的存储在同一个存储器里，并且顺序执行，指令由操作码和地址码组成，操作码决定了操作类型和所操作的数的数字类型，地址码则指出地址码和操作数。           从dos到window8，从unix到ubuntu和CentOS，还有MAC OS等等，不同的操作系统指令集以及数据结构都有着差异，而JVM通过在操作系统上建立虚拟机，...&hellip;</p>
       <div class="post-list__meta"><time datetime="2015-07-30 22:25:54 +0800" class="post-list__meta--date date">2015-07-30</time> &#8226; <span class="post-list__meta--tags tags">Java</span><a class="btn-border-small" href=/2015/07/jvm/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "/2015/08/list/";
        this.page.identifier = "/2015/08/list/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2016-07-03 生成</span>
        <span class="footer__copyright">本站由 <a href="http://mageric-one.com">@mageric</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
